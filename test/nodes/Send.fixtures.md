<!-- BEGIN_AUTOGENERATED -->

# Send Node Formatting

Represents a method call (e.g. `foo.bar(42)`)

<!-- END_AUTOGENERATED -->

## A method call on an impicit receiver is printed

Before:

```ruby
magic?
```

After:

```ruby
magic?
```

## When printing a negation, the `!` is always printed immediately before the receiver with no whitespace

Before:

```ruby
!! find_something
```

After:

```ruby
!!find_something
```

## When printing a negation after breaking, the `!` is always printed immediately before the receiver with no whitespace

Before:

```ruby
!have_you_ever_had_a_dream_in_which_you_were && !have_you_every_really_really_ever
```

After:

```ruby
!have_you_ever_had_a_dream_in_which_you_were &&
  !have_you_every_really_really_ever
```

## When printing exponentiation, the receiver and argument are printed around the operator without adjoining whitespace

Before:

```ruby
2 ** 8
```

After:

```ruby
2**8
```

## When printing setter methods, the `=` is printed with preceding whitespace

Before:

```ruby
self.enlightened =
  true
```

After:

```ruby
self.enlightened = true
```

## When printing a setter that is not part of a chain, the setter method is not broken from the receiver

Before:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = "localhost"
```

After:

```ruby
a_configuration_object_variable_that_cannot_be_broken
  .default_address = "localhost"
```

## When printing a setter that is part of a chain and the first arg is a hash, the setter method is not broken from the receiver

Before:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = {
  one: "two and three"
}
```

After:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = {
  one: "two and three"
}
```

## When printing a setter that is part of a chain and the first arg is an array, the setter method is not broken from the receiver

Before:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = %w(contents_of_the_array)
```

After:

```ruby
a_configuration_object_variable_that_cannot_be_broken
  .default_address = %w(contents_of_the_array)
```

## When printing a setter that is part of a chain and the first arg is an array, the setter method is not broken from the receiver (force break)

Before:

```ruby
a_configuration_object_variable_that_cannot_be_broken
  .default_address = %w(
    contents_of_the_array
  )
```

After:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = %w(
  contents_of_the_array
)
```

## When printing a setter that is part of a chain and the first arg is a begin, the setter method is not broken from the receiver

Before:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = (
  an_expression && spanning_lines
)
```

After:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = (
  an_expression && spanning_lines
)
```

## When printing a setter that is part of a chain and the first arg is a begin and the send exceeds the printwidth, the send is broken and indented

Before:

```ruby
a_much_longer_configuration_object_variable_that_cannot_be_broken
  .default_address = (an_expression && spanning_lines)
```

After:

```ruby
a_much_longer_configuration_object_variable_that_cannot_be_broken
  .default_address = (an_expression && spanning_lines)
```

## When printing a setter that is part of a chain, the setter method is not broken from the receiver

Before:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = {
  one: "two and three"
}
```

After:

```ruby
a_configuration_object_variable_that_cannot_be_broken.default_address = {
  one: "two and three"
}
```

## When printing a setter that is part of a chain, the setter method may be broken

Before:

```ruby
self
  .worker_connection_configuration
  .metrics_server
  .statsd
  .default_address = "localhost"
```

After:

```ruby
self
  .worker_connection_configuration
  .metrics_server
  .statsd
  .default_address = "localhost"
```

## When printing an operator method that is not part of a chain, the operator method is not broken from the receciver nor the argument

Before:

```ruby
a_configuration_object_variable_that_cannot_be_broken.power_level <= 1_000_000_000
```

After:

```ruby
a_configuration_object_variable_that_cannot_be_broken
  .power_level <= 1_000_000_000
```

## When printing an operator method that is part of a chain, the operator method is not broken from the receciver nor the argument

Before:

```ruby
self.worker_connection_configuration.metrics_server.statsd.power_level <= 1_000_000_000
```

After:

```ruby
self
  .worker_connection_configuration
  .metrics_server
  .statsd
  .power_level <= 1_000_000_000
```

## When printing a send on an Array receiver, the send is adjoined to the receiver without whitespace

Before:

```ruby
%w(
  something_in_this_array_causing_it_to_always_appear_multi-line
  something_else
).includes?("nothing")
```

After:

```ruby
%w(
  something_in_this_array_causing_it_to_always_appear_multi-line
  something_else
).includes?("nothing")
```

## When printing a send on a Hash receiver, the send is adjoined to the receiver without whitespace

Before:

```ruby
{
  something_in_this_hash_causing_it_to_always_appear_multi: "line",
  something_else: "in the hash"
}.key?(:nope)
```

After:

```ruby
{
  something_in_this_hash_causing_it_to_always_appear_multi: "line",
  something_else: "in the hash"
}.key?(:nope)
```

## When printing a send on a "wrapped" receiver (begin), the send is adjoined to the receiver without whitespace

Before:

```ruby
(
  variable_name_that_is_needfully_long_and_expressively_named && another_variable && (
    yes_this_is_also_a_begin
  ).nil?
).key?(:nope)
```

After:

```ruby
(
  variable_name_that_is_needfully_long_and_expressively_named &&
    another_variable &&
    (yes_this_is_also_a_begin).nil?
).key?(:nope)
```

# Chaining

## When printing a send chain on an Array receiver, the send chain continues in broken form

Before:

```ruby
%w(
  something_in_this_array_causing_it_to_always_appear_multi-line
  something_else
).includes?("nothing").without("nothing").compact
```

After:

```ruby
%w(
  something_in_this_array_causing_it_to_always_appear_multi-line
  something_else
).includes?("nothing")
  .without("nothing")
  .compact
```

## Allows a block on the same line when it fits

Before:

```ruby
[1, 2, 3].map { |i| i + 1 }
```

After:

```ruby
[1, 2, 3].map { |i| i + 1 }
```

## Breaks a block before breaking the send chain

Before:

```ruby
begin
  def self.categories
    self.types.map { |class_name| class_name.constantize.category } << :auto_listings_why_does_this
  end
end
```

After:

```ruby
begin
  def self.categories
    self.types.map do |class_name|
      class_name.constantize.category
    end << :auto_listings_why_does_this
  end
end
```

## chain 2

Before:

```ruby
begin
  def self.categories
    self.very_long_method_name.map { |class_name| class_name.constantize.category } << :a
  end
end
```

After:

```ruby
begin
  def self.categories
    self.very_long_method_name.map do |class_name|
      class_name.constantize.category
    end << :a
  end
end
```

## chain 3

Before:

```ruby
begin
  def self.categories
    self.types.map { |class_name| class_name.constantize.category }.some_other_long_method 'arg'
  end
end
```

After:

```ruby
begin
  def self.categories
    self
      .types
      .map { |class_name| class_name.constantize.category }
      .some_other_long_method "arg"
  end
end
```

## chain 3 (forced newline)

Before:

```ruby
begin
  def self.categories
    self
      .types.map { |class_name| class_name.constantize.category }
      .some_other_long_method 'arg'
  end
end
```

After:

```ruby
begin
  def self.categories
    self
      .types
      .map { |class_name| class_name.constantize.category }
      .some_other_long_method "arg"
  end
end
```

## chain 4

Before:

```ruby
::Hashtronaut.simple_fetch(self.config_layout, "meta.defaults", {}).each do |component_code, defaults_hash|
  next unless defaults_hash.try(:[], :validate_against_default_text)

  default_text = defaults_hash[:text]
end
```

After:

```ruby
::Hashtronaut
  .simple_fetch(self.config_layout, "meta.defaults", {})
  .each do |component_code, defaults_hash|
    next unless defaults_hash.try(:[], :validate_against_default_text)

    default_text = defaults_hash[:text]
  end
```

Before:

```ruby
foo( "an arg")
```

After:

```ruby
foo("an arg")
```

## Formats detached method names (<<)

Before:

```ruby
foo <<
  "one"
```

After:

```ruby
foo << "one"
```

## Formats detached method names (=~)

Before:

```ruby
/[a]/ =~ [bcd]
```

After:

```ruby
/[a]/ =~ [bcd]
```

## Formats detached method names (=)

Before:

```ruby
foo.bar= 1
```

After:

```ruby
foo.bar = 1
```

## Formats detached method names (>=)

Before:

```ruby
foo.bar >= 1
```

After:

```ruby
foo.bar >= 1
```

## Formats with an operator assignment (|=)

Before:

```ruby
foo.bar |= 1
```

After:

```ruby
foo.bar |= 1
```

## Formats with an operator assignment (^=)

Before:

```ruby
foo.bar ^= 1
```

After:

```ruby
foo.bar ^= 1
```

## Formats a chain

Before:

```ruby
key_component.gsub(/[[:space:]]+/, " ").gsub(/[^[:alnum:][:space:]]/, "").titleize
```

After:

```ruby
key_component
  .gsub(/[[:space:]]+/, " ")
  .gsub(/[^[:alnum:][:space:]]/, "")
  .titleize
```

## Formats a chained assignment

Before:

```ruby
self.telemetry.tracked_data = { things_to_count_and_summarize: (metrics || []).length }
```

After:

```ruby
self
  .telemetry
  .tracked_data = { things_to_count_and_summarize: (metrics || []).length }
```

## Formats a chained assignment (forced break)

Before:

```ruby
self.telemetry.tracked_data = {
  things_to_count_and_summarize: (metrics || []).length }
```

After:

```ruby
self.telemetry.tracked_data = {
  things_to_count_and_summarize: (metrics || []).length
}
```

## Formats a chained assignment

Before:

```ruby
self.telemetry.tracked_data = 2
```

After:

```ruby
self.telemetry.tracked_data = 2
```

## Formats when a line prints too long and the method is `==`

Before:

```ruby
def product_for_preview_image_type(preview_image_type)
  products.detect do |selected_product|
    selected_product.default_ad_preview_image_type.to_s == preview_image_type.to_s
  end
end
```

After:

```ruby
def product_for_preview_image_type(preview_image_type)
  products.detect do |selected_product|
    selected_product.default_ad_preview_image_type.to_s == preview_image_type
      .to_s
  end
end
```

## Formats correctly with a negation

Before:

```ruby
!self.programmatically_created? || self.author.user.require_publisher_approval_on_all_posts
```

After:

```ruby
!self.programmatically_created? ||
  self.author.user.require_publisher_approval_on_all_posts
```

## Formats correctly with a negation

Before:

```ruby
return false if field_name.blank? || (!validate_draft_fields.is_a?(Hash) && !validate_draft_fields.is_a?(Array))
```

After:

```ruby
return false if field_name.blank? ||
  (!validate_draft_fields.is_a?(Hash) && !validate_draft_fields.is_a?(Array))
```

## Formats when a chain breaks a line and part of the chain is the `==` method

Before:

```ruby
using_default_text =
  ::Hashtronaut.simple_fetch(
    self.ad_config.try(:with_indifferent_access) || {},
    "#{component_code}.text"
  ).to_s == default_text
```

After:

```ruby
using_default_text =
  ::Hashtronaut
    .simple_fetch(
      self.ad_config.try(:with_indifferent_access) || {},
      "#{component_code}.text"
    )
    .to_s == default_text
```

## Fits blocks in a chain onto the line when the chain breaks

Before:

```ruby
product_specs_of(categories: categories).map { |clazz, _specs| clazz.try(:name) || clazz.try(:to_s) }
  .compact { |b| b + 1 }
```

After:

```ruby
product_specs_of(categories: categories)
  .map { |clazz, _specs| clazz.try(:name) || clazz.try(:to_s) }
  .compact { |b| b + 1 }
```

## Preserves an arg list on the same line as the second and last arg is a block

Before:

```ruby
scope :purchased_or_recently_completed, -> do
  where(status: self.all_statuses(:purchased))
    .where(
      "completed_at > ? OR completed_at IS NULL", 2.weeks.ago.to_date
    ).where(
      "canceled_at > ? OR canceled_at IS NULL", 2.weeks.ago.to_date
    )
end
```

After:

```ruby
scope :purchased_or_recently_completed, -> do
  where(status: self.all_statuses(:purchased))
    .where("completed_at > ? OR completed_at IS NULL", 2.weeks.ago.to_date)
    .where("canceled_at > ? OR canceled_at IS NULL", 2.weeks.ago.to_date)
end
```

## Formats with an implicit call

Before:

```ruby
foo.(52)
```

After:

```ruby
foo.(52)
```

## Formats with `~` operator (bitwise complement)

Before:

```ruby
~2
```

After:

```ruby
~2
```

## Formats with `+` operator (unary plus)

Before:

```ruby
+"foo"
```

After:

```ruby
+"foo"
```

## Formats with `**` operator (exponentiation)

Before:

```ruby
2**8
```

After:

```ruby
2**8
```

## Formats with `-` operator (unary minus)

Before:

```ruby
-"foo"
```

After:

```ruby
-"foo"
```

## Formats with `*` operator (multiplication)

Before:

```ruby
1*2
```

After:

```ruby
1 * 2
```

## Formats with `/` operator (division)

Before:

```ruby
1/0
```

After:

```ruby
1 / 0
```

## Formats with `%` operator (modulo)

Before:

```ruby
9 % 3
```

After:

```ruby
9 % 3
```

## Formats with `+` operator (addition / concatentation)

Before:

```ruby
4+ 3
```

After:

```ruby
4 + 3
```

## Formats with `<<` operator (bitshift left)

Before:

```ruby
0 << 1
```

After:

```ruby
0 << 1
```

## Formats with `>>` operator (bitshift right)

Before:

```ruby
1 >> 0
```

After:

```ruby
1 >> 0
```

## Formats with `&` operator (bitwise AND)

Before:

```ruby
2&10
```

After:

```ruby
2 & 10
```

## Formats with `|` operator (bitwise OR)

Before:

```ruby
1|9
```

After:

```ruby
1 | 9
```

## Formats with `^` operator (bitwise XOR)

Before:

```ruby
1 ^ 2
```

After:

```ruby
1 ^ 2
```

## Formats with `<` operator (lt)

Before:

```ruby
1 <2
```

After:

```ruby
1 < 2
```

## Formats with `<=` operator (lte)

Before:

```ruby
1 <= 5
```

After:

```ruby
1 <= 5
```

## Formats with `>=` operator (gte)

Before:

```ruby
4  >= 10
```

After:

```ruby
4 >= 10
```

## Formats with `>` operator (gt)

Before:

```ruby
 10 > 0
```

After:

```ruby
10 > 0
```

## Formats with `==` operator (equality)

Before:

```ruby
foo == foo
```

After:

```ruby
foo == foo
```

## Formats with `===` operator (pattern match)

Before:

```ruby
foo === foo
```

After:

```ruby
foo === foo
```

## Formats with `!=` operator (ne)

Before:

```ruby
1 != 4
```

After:

```ruby
1 != 4
```

## Formats with `=~` operator (regex)

Before:

```ruby
"foo bar" =~ /bar/
```

After:

```ruby
"foo bar" =~ /bar/
```

## Formats with `!~` operator

Before:

```ruby

```

After:

```ruby

```

## Formats with `<=>` operator (sort)

Before:

```ruby
1 <=> 5
```

After:

```ruby
1 <=> 5
```

## if the top of the chain has a block and the chain contains no other blocks, group the send chain, allowing breaks on each send

Before:

```ruby
scope :purchased_or_recently_completed, -> do
  where(status: self.all_statuses(:purchased)).where("#{Trip.table_name}.completed_at > ? OR #{
        Trip.table_name
      }.completed_at IS NULL", 2.weeks.ago.to_date )
    .where("#{Trip.table_name}.canceled_at > ? OR #{Trip.table_name}.canceled_at IS NULL", 2.weeks.ago.to_date)
end
```

After:

```ruby
scope :purchased_or_recently_completed, -> do
  where(status: self.all_statuses(:purchased))
    .where(
      "#{Trip.table_name}.completed_at > ? OR #{
        Trip.table_name
      }.completed_at IS NULL",
      2.weeks.ago.to_date
    )
    .where(
      "#{Trip.table_name}.canceled_at > ? OR #{
        Trip.table_name
      }.canceled_at IS NULL",
      2.weeks.ago.to_date
    )
end
```

## if more than one block exists in the send chain, break it

Before:

```ruby
product_specs_of(categories: categories).map do |clazz, _specs|
  clazz.try(:name) || clazz.try(:to_s)
end.each { |b| b + 1 }
```

After:

```ruby
product_specs_of(categories: categories)
  .map { |clazz, _specs| clazz.try(:name) || clazz.try(:to_s) }
  .each { |b| b + 1 }
```

## Preserves an arg and a block starting on the same line if the author formatted it as such

Before:

```ruby
scope "/api", -> do
  scope "/v1", -> do
    get("trips").to(controller: "something", action: "else")
  end
end
```

After:

```ruby
scope "/api", -> do
  scope "/v1", -> do
    get("trips").to(controller: "something", action: "else")
  end
end
```

## Preserves an arg and a block starting on the same line if the author formatted it as such, while also preserving another block's one-line fit

Before:

```ruby
scope "/api", -> do
  scope "/v1", -> { get("trips").to("something#else") }
end
```

After:

```ruby
scope "/api", -> do
  scope "/v1", -> { get("trips").to("something#else") }
end
```

## Ex1

Before:

```ruby
if true
  if true
    if true
      RecordLock.new(record: campaign.group).lock! do
        post(
          edit_ad_account_brand_radius_path(
            account,
            id: campaign.id,
            action: :edit_ad_save
          )
        )
      end
    end
  end
end
```

After:

```ruby
if true
  if true
    if true
      RecordLock.new(record: campaign.group).lock! do
        post(
          edit_ad_account_brand_radius_path(
            account,
            id: campaign.id,
            action: :edit_ad_save
          )
        )
      end
    end
  end
end
```

## Ex3

Before:

```ruby
class Thing
  module Thing
    def something
      if true
        add_proc(
          -> do
            where("#{Transaction.table_name}.bit_flags & #{Transaction.bit_mask(:coupon_not_reusable)} = 0")
              .order("#{Coupon.table_name}.code ASC")
          end
        )
      end
    end
  end
end
```

After:

```ruby
class Thing
  module Thing
    def something
      if true
        add_proc(
          -> do
            where(
              "#{Transaction.table_name}.bit_flags & #{
                Transaction.bit_mask(:coupon_not_reusable)
              } = 0"
            )
              .order("#{Coupon.table_name}.code ASC")
          end
        )
      end
    end
  end
end
```

## Ex4

Before:

```ruby
open_houses_payload = batch.flat_map do |item|
  next unless item.record.persisted?

  item.payload[:open_houses]&.map do |open_house|
    open_house[:partner_listing_id] = item.record.id
    open_house
  end
end.compact
```

After:

```ruby
open_houses_payload = batch
  .flat_map do |item|
    next unless item.record.persisted?

    item.payload[:open_houses]&.map do |open_house|
      open_house[:partner_listing_id] = item.record.id
      open_house
    end
  end
  .compact
```
